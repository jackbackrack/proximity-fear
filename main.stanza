; Generated by JITX 1.1.2-rc.2
#use-added-syntax(jitx)
defpackage main :
  import core
  import math
  import collections
  import jitx
  import jitx/commands
  import ocdb/utils/defaults
  import ocdb/utils/landpatterns
  import ocdb/utils/box-symbol
  import ocdb/utils/bundles
  import ocdb/utils/generic-components
  import ocdb/utils/symbols
  import ocdb/utils/property-structs
  import ocdb/utils/checks
  import ocdb/utils/generator-utils
  import ocdb/utils/connects
  import ocdb/utils/design-vars
  import checks
  import helpers
  import jitx/geometry/operators/boolean
  import jitx/geometry/operators/offset with:
    prefix(offset) => operator-

defn ring-locs (diameter:Double, distance:Double) -> Seq<Pose> :
  val r = diameter / 2.0
  val circumference = 2.0 * PI * r
  val n = round(circumference / distance)
  val angle = 2.0 * PI / n
  for i in 0 to (to-int(n) + 1) seq :
    val a = 2.0 * PI * to-double(i) / (n + 1.0)
    loc(Point(r * cos(a), r * sin(a)), a * 180.0 / PI)

public pcb-module leds (locs*:Seqable<Pose>) :
  pin a
  val locs = to-tuple(locs*)
  val n = length(locs)
  port k : pin[n]
  inst led : database-part(["vendor_part_numbers.lcsc" => "C2290"])[n]
  for (pose in locs, i in 0 to false) do :
    net (led[i].A a)
    net (k[i] led[i].K)
    place(led[i]) at pose on Top
  schematic-group(self) = led-ring
  layout-group(self) = led-ring

; Implement other modules used by our design 
; ==========================================
MIN-CAP-VOLTAGE = 10.0
DESIGN-QUANTITY = 1
; val board-shape = RoundedRectangle(110.0, 52.0, 0.25)
val board-shape = boolean-union $ [RoundedRectangle(50.0, 52.0, 0.25, loc(-14.0, 0.0)), Circle(Point(10.0, 0.0), 26.0)]
; val real-board-shape = boolean-difference(board-shape, Circle(Point(10.0, 0.0), 13.2 / 2.0))

; ==========================================
; Configure the design, then run or check it
; ==========================================
defn run-design (circuit:Instantiable, run-checks?:True|False) :
  ; set-paper(ANSI-A5)
  set-current-design("hackathon-2022")
  set-bom-vendors([ JLCPCB, DigiKey ])
  set-bom-design-quantity(0)
  set-board(ocdb/utils/defaults/default-board(ocdb/manufacturers/stackups/jlcpcb-jlc2313, board-shape))
  set-rules(ocdb/manufacturers/rules/jlcpcb-rules)

  ; We may have to fix db-parts on the fly, and want people to get fixes automatically.
  ; Okay to always send queries for the hackathon.
  ; clear-dbquery-cache()

  var main-module = circuit

  if run-checks? :
    main-module = ocdb/utils/generator-utils/run-final-passes(circuit) ; Analyze design with a pass
  
  set-main-module(main-module) ; Treat the provided module as a design, and compile it.
  set-use-layout-groups()
  if run-checks? :
    run-checks("checks.txt")
    view-design-explorer()
    ; export-design()
  else:  
    view-board()
    view-schematic()
    ; view-design-explorer()
    ; export-design()

; ; We want decoupling capacitors to be close to the component being decoupled
; defn bypass-cap-strap (power-pin:JITXObject, gnd-pin:JITXObject, params:Tuple<KeyValue>) -> JITXObject :
;   inside pcb-module:
;     val cap = cap-strap(gnd-pin, power-pin, params)
;     short-trace(cap.p[2], power-pin)
;     cap
    
public pcb-module led-driver :
  pin vdd
  pin gnd
  port i2c : i2c

  public inst u : components/IS31FL3236A-QFLS2-TR/component
  bypass-cap-strap(u.VCC, gnd, ["capacitance" => 2.2e-6, "mounting" => "smd", "max-case" => "0603", "_exist" => ["vendor_part_numbers.lcsc"]])
  net (u.VCC vdd)
  net (u.GND[0] u.GND[1] u.EPAD gnd u.AD)
  net (vdd u.SDB)
  net (i2c.sda u.SDA)
  net (i2c.scl u.SCL)
  res-strap(u.R-EXT gnd, ["resistance" => 3.3e3, "mounting" => "smd", "max-case" => "0603", "_exist" => ["vendor_part_numbers.lcsc"]])
  schematic-group(self) = led-driver
  layout-group(self) = led-driver

public pcb-module class-d-audio :
  pin in 
  pin vdd
  pin gnd
  pin en

  ; Low pass the PWM @ 20 KHz
  inst r : chip-resistor(closest-std-val(80.0, 5.0))
  net (r.p[1] in )
  cap-strap(r.p[2] gnd, ["capacitance" => 0.1e-6, "mounting" => "smd", "max-case" => "0603", "_exist" => ["vendor_part_numbers.lcsc"]])

  inst d : database-part(["manufacturer" => "Diodes Incorporated", "mpn" => "PAM8302AADCR"])

  ;inst vol : database-part(["manufacturer" => "ALPSALPINE", "mpn" => "RK09K1130AP5"]) ; out of stock at JLCPCB
  inst vol : database-part(["manufacturer" => "ALPSALPINE", "mpn" => "RK09K1130ACL"]) ; in stock at JLCPCB
  net (vol.p[3] r.p[2])
  cap-strap(vol.p[2], d.IN+, ["capacitance" => 0.1e-6, "mounting" => "smd", "max-case" => "0603", "_exist" => ["vendor_part_numbers.lcsc"]])
  cap-strap(vol.p[1], d.IN-, ["capacitance" => 0.1e-6, "mounting" => "smd", "max-case" => "0603", "_exist" => ["vendor_part_numbers.lcsc"]])

  net (d.VDD vdd)
  bypass-cap-strap(d.VDD, gnd, ["capacitance" => 10.0e-6, "mounting" => "smd", "max-case" => "0603", "_exist" => ["vendor_part_numbers.lcsc"]])
  net (d.GND gnd)
  net (d.SD_NOT en)

  inst speaker : pin-header(2)
  inst r- : chip-resistor(closest-std-val(0.0, 5.0))
  inst r+ : chip-resistor(closest-std-val(0.0, 5.0))
  net (r-.p[1] d.VO- )
  val c- = cap-strap(r-.p[2] gnd, ["capacitance" => 0.1e-6, "mounting" => "smd", "max-case" => "0603", "_exist" => ["vendor_part_numbers.lcsc"]])
  net (r+.p[1] d.VO+ )
  val c+ = cap-strap(r+.p[2] gnd, ["capacitance" => 0.1e-6, "mounting" => "smd", "max-case" => "0603", "_exist" => ["vendor_part_numbers.lcsc"]])
  do-not-populate(c-)
  do-not-populate(c+)

  net (speaker.p[1] r-.p[2])
  net (speaker.p[2] r+.p[2])
  do-not-populate(speaker)
  schematic-group(self) = class-d
  layout-group(self) = class-d

; =========================
; Module to run as a design
; ==========================
public pcb-module buddha :
  ; USB
  inst usb : usb2-on-a-usb-c-connector(ocdb/components/korean-hroparts-elec/TYPE-C-31-M-23/module(SinkDefault))
  net GND (usb.usb-2.vbus.gnd)
  symbol(GND) = ground-sym
  property(GND.voltage) = typ(0.0)
  ;; set net classes for usb
  ; val usb-net-class = NetClass(`USB-net-class, [`min-trace => 0.8])
  ; net USB-NET-DN (usb.con.conn.DN1)
  ; net USB-NET-DP (usb.con.conn.DP1)
  ; property(USB-NET-DP.net-class) = usb-net-class
  ; property(USB-NET-DP.net-class) = usb-net-class

  ; Power - battery
  inst battery : database-part(["vendor_part_numbers.lcsc" => "C47647"])
  ; inst battery : database-part(["mpn" => "PH-2P", "manufacturer" => "BOOMELE(Boom Precision Elec)"])
  net (battery.p[1] GND)

  ; battery charging
  inst charger : components/BQ24078RGTR/module
  net VBAT (battery.p[2] charger.bat+)
  net (charger.gnd GND)

  ; power switch
  inst sw : database-part(["manufacturer" => "G-Switch", "mpn" => "MK-12C02-G025"])
  net SW-VOUT (sw.p[2] charger.vout)
  net P4V2 (sw.p[3])
  property(P4V2.voltage) = min-max(3.5 5.0)
  net VBUS (charger.vin usb.usb-2.vbus.vdd)

  ; power - LDO
  inst ld : components/AP2125K-2_8TRG1/module
  net (P4V2 ld.vin ld.en)
  net (ld.gnd, GND)
  net P2V8 (ld.vout)

  ; set net symbols
  symbol(VBAT) = supply-sym
  symbol(VBUS) = supply-sym
  symbol(P4V2) = supply-sym
  symbol(P2V8) = supply-sym

  ; RP2040
  inst rpi : components/RP2040/module
  net (GND rpi.gnd)
  net (usb.usb-2.data rpi.usb)
  schematic-group(rpi) = rpi
  layout-group(rpi) = rpi
  net (rpi.vdd P2V8)

  ; LED driver
  inst led-drive : led-driver
  net (led-drive.gnd GND)
  net (led-drive.vdd P4V2)
  require rpi-led-i2c : i2c from rpi.mcu
  ; net (l.i2c, led-i2c)
  ; val i2c-pu = add-open-drain-pullups(l.i2c, P2V8)

  ; LED driver I2C level shifter
  inst led-driver-shifter : components/logic-level-shifter/i2c-level-shifter-module
  net (led-driver-shifter.gnd GND) 
  net (led-driver-shifter.lv P2V8) 
  net (led-driver-shifter.hv P4V2) 
  net (led-driver-shifter.lv-i2c rpi-led-i2c) 
  net (led-driver-shifter.hv-i2c led-drive.i2c) 

  schematic-group(led-driver-shifter) = schematic-group(led-drive)

  ; Switched single-color led rings
  val n-rings = 3
  val ring-lens = Vector<Int>()
  val white-rings = to-tuple $ for i in 0 to n-rings seq :
    val d = 30.0 + to-double(i) * 8.0
    val locs = to-tuple $ seq({ loc(10.0, 0.0, 0.0) * _ }, ring-locs(d, 5.0))
    add(ring-lens, length(locs))
    inst led-ring : leds(locs)
    led-ring
  inst en-sw : components/high-side-switch/high-side-switch()[n-rings]
  require enable : gpio[n-rings] from rpi.mcu

  val max-lens = reduce(fn (a:Int, b:Int) : max(a, b), 0, ring-lens)
  require drive : gpio[max-lens] from led-drive.u
  for (len in ring-lens, i in 0 to false) do :
    net (en-sw[i].power.vdd  P4V2)   
    net (en-sw[i].power.gnd  GND)
    net (en-sw[i].input enable[i].gpio)
    net (en-sw[i].output white-rings[i].a)
    schematic-group(en-sw[i]) = schematic-group(white-rings[i])
    layout-group(en-sw[i]) = layout-group(white-rings[i])
    for j in 0 to len do :
      net (white-rings[i].k[j] drive[j].gpio)

  for i in 0 to n-rings do :
    place(white-rings[i]) at loc(0.0, 0.0) on Top
  
  ; for i in 0 to 2 do :
  ;   net (en-sw[i].power.vdd  P4V2)
  ;   net (en-sw[i].power.gnd  GND)
  ;   net (en-sw[i].input enable[i].gpio)

  ; Speaker
  inst amp : class-d-audio
  require pwm : timer from rpi.mcu
  require audio-enable : gpio from rpi.mcu
  net (pwm.timer, amp.in)
  net (audio-enable.gpio, amp.en)
  net (P4V2 amp.vdd)
  net (GND amp.gnd)

  ; Distance sensor
  inst tof : components/VL53L0CXV0DH_1/module

  require tof-i2c : i2c from rpi.mcu
  net (tof.i2c tof-i2c)
  add-open-drain-pullups(tof.i2c, P2V8)

  net (tof.power.vdd P2V8)
  net (tof.power.gnd GND)
  require tof-en : gpio from rpi.mcu
  net (tof-en.gpio tof.x-shut)
  res-strap(tof.x-shut, P2V8, ["resistance" => 8.2e3, "mounting" => "smd", "max-case" => "0603", "_exist" => ["vendor_part_numbers.lcsc"]])

  ; create copper pours
  geom(GND) :
    ; copper-pour(LayerIndex(1), isolate = 0.1, rank = 1) = Rectangle(width(board-shape) - 1.0, height(board-shape) - 1.0)
    copper-pour(LayerIndex(1), isolate = 0.1, rank = 1) = operator-offset(board-shape, -1.0)
  geom(P4V2) :
    ; copper-pour(LayerIndex(2), isolate = 0.1, rank = 1) = Rectangle(width(board-shape) - 1.0, height(board-shape) - 1.0)
    copper-pour(LayerIndex(2), isolate = 0.1, rank = 1) = operator-offset(board-shape, -1.0)

  ; set net classes for power
  val power-net-class = NetClass(`Power-HV, [`min-trace => 0.381])
  property(GND.net-class) = power-net-class
  property(P4V2.net-class) = power-net-class
  property(VBUS.net-class) = power-net-class
  property(VBAT.net-class) = power-net-class
  property(SW-VOUT.net-class) = power-net-class
  val low-power-net-class = NetClass(`Power-LV, [`min-trace => 0.254])
  property(P2V8.net-class) = low-power-net-class

  check-design(self)

run-design(buddha, false)